\section{Recherche}
\label{sec:Recherche}
Die Informationen, die das Projektteam

\subsection{Verwendete Blockchain Implementation}
Dieses Projekt verwendet die open-source Blockchain-Implementation Ethereum als Plattform für die Datenhaltung, die Business Logik in Form von Smart Contracts (vgl. \ref{subsec:Recherche_Smart_Contracts}) und einzige Interaktionsmöglichkeit für Benutzer mit dem System.

Ethereum ist die einzige Implementation einer Blockchain, die zum Start dieses Projektes eine funktionsfähige Plattform für eine Kryptowährung und Smart Contracts zur Verfügung stellt. Weitere Blockchain Technologien, die in der Evaluationsphase analysiert wurden, sind Hyperledger und Bitcoin. Diese beiden unterstützen jedoch (noch) keine Smart Contracts.\cite{ethereum.org}\cite[welcome]{wiki.hyperledger.org}

\paragraph{Konsensus}
Alle bisherigen Versionen des Ethereum Protokolls (Olympic, Frontier, Homestead) verwenden den \emph{Proof of Work} Algorithmus Ethash, um Konsensus zu erreichen. Dies bedeutet, dass für jede Transaktion eine rechenintensive Operation, genannt \emph{proof}, durchgeführt werden muss, bevor die Transaktion offiziell in die Blockchain eingetragen werden kann.\cite{Ethash}

Für zukünftige Implementationen des Ethereum Protokolls ist ein \emph{Proof of Authority} Algorithmus vorgesehen. Grund dafür ist, dass die Kosten eine Blockchain anzugreifen, die einen Proof of Work Konsensus benutzt, zusammen mit den Betriebskosten wachsen. Folglich kann ein Hochsicherheitssystem, wie es für Finanzdienstleistungen wie Banken oder Treuhänder benötigt würde, nur durch entsprechend hohe Betriebskosten realisiert werden. Ein wiederkehrendes Argument ist auch die Energie-Ineffizienz dieser Algorithmen. Aufgrund der benötigten hohen Rechenleistung sind Miner dazu geneigt ihre Rechenleistung zu konsolidieren und zu zentralisieren. Ursprünglich war ein \emph{Proof of Stake} Algorithmus angedacht, der jedoch aufgrund gravierender Sicherheitslücken verworfen werden musste.\cite{github.com/ethereum_poa,coinmanual.com/pos,bitcoin.it/pos,cost_nothing_kill_pos,tendermint.com/intro}\cite[{Frequently Asked Questions/What’s the future of Ethereum?}]{ethereum-homestead.readthedocs.io}

\paragraph{Light Node}
\label{para:Light_Node}

Als Light Node wird eine Ethereum Blockchain Node bezeichnet, die nicht eine komplette Kopie der verteilten Datenbank lokal hält, sondern lediglich die Headerinformationen der Transaktionen. Sie bietet aber ein Interface zu der Blockchain über das \emph{les} Protokoll. Benötigte Daten können so von den verbundenen peers abgefragt werden. Diese Konfiguration ist speziell für Geräte mit weniger Speicherplatz oder keiner Breitband Internetverbindung angedacht.\cite[]{go-ethereum}
\paragraph{Solidity}
Solidity ist eine Programmiersprache, die auf der \acrfull{EVM} läuft, um Smart Contracts zu verfassen. Mehrere Sprachen konkurrieren mit Solidity, namentlich LLL und Serpent. Hierbei ist zu beachten, dass Solidity auf anderen Platformen wie Hyperledger Burrow durch eine Implementation der Ethereum VM ebenfalls lauffähig sein wird.\cite{github.com/hyperledger/burrow}

\paragraph{Whisper}
\label{para:Whisper}
Whisper v5, auch analog zu der öffentlichen API \emph{shh} genannt, ist ein Kommunikationsprotokoll für \acrfull{DAPPs}. Nachrichten, die über das Whisper Protokoll verschickt werden, benutzen zur Übermittlung ebenfalls Ethereum Nodes, auf welchen das \emph{shh} Protokoll aktiviert wurde. Diese Nachrichten lösen keine Transaktionen auf der Blockchain aus. Wie auch die Transaktionen werden die Whisper Messages an alle Teilnehmer gesendet (broadcast), können aber mit einem \emph{topic} versehen werden, das es vereinfacht, erhaltene Nachrichten zu filtern. Jede Nachricht kann mit einer \acrfull{ttl} versehen werden, die angibt, wie lange die Nachricht verfügbar sein soll. Wenn diese Zeitspanne abläuft wird die Nachricht von den Ethereum Nodes nicht mehr weitergeleitet (Stale Message) und steht auf den Nodes, die die Nachricht bereits erhalten haben, nicht mehr zur Verfügung. So bietet das Whisper Protokoll eine einfache, leichtgewichtige Möglichkeit zur Echtzeit-Kommunikation für \acrshort{DAPPs}.

\subsection{Öffentliche Ethereum Testchain}
\label{subsec:oeffentliche_testchain}
Die Ethereum Implementation stellt hart-kodiert zwei öffentliche Netzwerke zur Verfügung. Zum einen die produktiv verwendete Chain \emph{Homestead}, auf der mit physischer Währung Ether gehandelt wird\cite[{Ether}]{ethereum-homestead.readthedocs.io}. Zum anderen das \emph{Ropsten} Netzwerk, das als aktuelle Testchain dient. Obwohl das Mining auf der Testchain ebenfalls mit erheblicher Rechenleistung verbunden ist, kann Ether auf der Testchain nicht gegen \emph{echte} Währung eingetauscht werden.

\paragraph{Faucet Request}
\label{para:Faucet_Request}
Auf allen Testchains können sogenannte \emph{Faucet Requests} gemacht werden, wodurch Ether erhalten werden kann. Dieser Ether wird von Entwicklern, die aktiv Mining betreiben, zur Verfügung gestellt und kann dann von weiteren Entwicklern verlangt werden. Meist ist ein Limit auf der Menge Ether pro Minute oder Adresse verhängt, das missbräuchliche Nutzung dieses Dienstes verhindern soll. Ziel dieser Faucets ist es, Entwicklern eine Möglichkeit zu geben, die öffentliche Testchain zu verwendet, ohne dabei selbst Mining betreiben zu müssen.\cite{blog.b9lab.com/faucet,ethereum.stackexchange.com/faucets}

\subsection{Private Chain mit Ethereum}
\label{subsec:private_chain}
Durch Wunsch des Auftraggebers wurde eine Anbindung an die öffentliche \emph{Ropsten} Testchain (vgl. \ref{subsec:oeffentliche_testchain}) ausgeschlossen, da die ständige Verfügbarkeit des Internets auf den IoT devices oder die Disponibilität von Ether nicht gewährleistet sein kann. Folglich wurde eine private Blockchain auf der zur Verfügung gestellten Infrastruktur installiert (vgl. \ref{sys_sec:Demonstrator_Aufbau}). Um eine private Blockchain aufzusetzen wird ein Genesis Block benötigt und es müssen bestehende Nodes bekannt sein, die als peers hinzugefügt werden können.

\paragraph{Genesis Block}
In einer Blockchain wird der erste Block Genesis Block genannt. Hier werden initiale Kontostände (oft für die Entwickler oder Contributors) angelegt und unterschiedliche Konfigurationen bezüglich der Chain vorgenommen.
Um eine Verbindung zu einem Peer aufzubauen muss der Genesis Block auf beiden Nodes übereinstimmen. Wenn dies der Fall ist, kann der Synchronisierungsprozess beginnen.

\subsection{Konzept der Smart Contracts}
\label{subsec:Recherche_Smart_Contracts}
``A computerized transaction protocol that executes the terms of a contract.''\cite{BlockchainRevolution}

Mit diesem Zitat kann grob das Ziel von Smart Contracts beschrieben werden. Dies sind Verträge, die in einem maschinenlesbaren Format verfasst sind und können unmissverständlich und ohne Interpretationsspielraum deterministisch definiert werden. So ist es möglich, einen in jedem Fall vorhersehbaren digitalen Vertrag zu aufzusetzen.

\subsubsection{Ausnahmesituationen}
Eine Ausnahmesituation, bei der die Ausnahme nicht im Vertrag festgehalten wurde, kann nicht berücksichtigt werden, ohne dass eine Hintertür eingebaut wird. Was seinerseits den Nutzen der deterministischen Natur der Smart Contracts nichtig machen würde.
Wenn ein Smart Contract beispielsweise die Vermietung einer Wohnung abbilden soll, muss der Beschädigungs- oder Verschmutzunggrad des Objektes meist von Menschen geschätzt werden und kann selten durch Sensoren bestimmt und in der Blockchain eingetragen werden. Auch wenn dies möglich wäre, müsste man sich auf die korrekte Funktionsweise der Sensoren verlassen können.\cite{ibtimes.co.uk/abiguity}

\subsubsection{Neuerstellung}
\label{subsubsec:Neuerstellung}
Um einen Smart Contract zu erstellen, wird dieser mittels einer unterstützten Programmiersprache formell definiert. Dieser geschriebene Programmcode wird durch einen entsprechenden Compiler zu von der EVM ausführbaren Maschinencode compiliert. Dieser Maschinencode kann durch eine Transaktion in die Blockchain eingesetzt werden, wobei Initialwerte für den Smart Contract angegeben werden. Man sprich hierbei vom erstellen einer Instanz des Smart Contracts, analog der Erstellung einer Instanz einer Klasse in der objektorientierten Programmierung. Bei der ausgelösten Transaktion gilt es zu beachten, dass dieser kein Empfänger angegeben wird; der Empfänger dieser Transaktion ist die Blockchain selbst. Wie bei jeder Transaktion muss eine gewisse Menge Gas mitgegeben werden, damit die Operation abgeschlossen werden kann. Wenn der Code in die Blockchain eingesetzt wurde, erhält diese Instanz des Contracts eine Adresse, über die später mit dieser spezifischen Instanz interagiert werden kann.\cite[Solidity in Depth/Contracts/Creating Contracts]{solidity.readthedocs.io}

Beim Kompilieren eines Smart Contracts wird auch ein \acrfull{ABI} generiert. Dieses beschreibt die möglichen verfügbaren Attribute des Contracts und die Funktionen inklusive derer allfälligen Parameter und Rückgabewerte. Dieses wird benötigt, um später eine bereits erstellte Instanz eines Smart Contracts aus de Blockchain zu laden. \cite{media.consensys.net/events-and-logs}

\subsubsection{Laden}
Wenn ein Contract, wie in Kapitel \ref{subsubsec:Neuerstellung} erwähnt, bereits erstellt wurde, kann er anhand seiner Adresse geladen werden.\cite[Solidity in Depth/Contracts/Creating Contracts]{solidity.readthedocs.io} Dazu wird neben der Adresse das \acr{ABI} benötigt. Diese Operation erfordert kein mitgegebenes gas, da es eine Leseoperation (vgl. \ref{subsubsec:Lesezugriff}) ist. Schreiboperationen (vgl. \ref{subsubsec:Schreibzugriff}) auf dem geladenen Smart Contract auszuführen kostet gleich viel gas, wie wenn der Vertrag lokal erstellt wurde.

\subsubsection{Lesezugriff}
\label{subsubsec:Lesezugriff}
Um ein Attribut auszulesen oder eine Funktion mit konstantem Rückgabewert auszuführen, kann diese über ein verfügbares Interface, wie die JavaScript console von geth, direkt aufgerufen werden. Bei Funktionen mit konstantem Rückgabewert ist zu beachten, dass diese nur auf der lokalen Node emuliert werden und es somit nicht möglich ist, eine Änderung in der Blockchain zu bewirken.\cite{media.consensys.net/events-and-logs} Diese Funktionen haben folglich nur Lesezugriff. Allfällige Events, die in einer konstanten Funktion definiert wurden, werden nicht ausgelöst und keine entsprechenden Logs in der Blockchain generiert.

\subsubsection{Schreibzugriff}
\label{subsubsec:Schreibzugriff}
Wenn eine Funktion auf der Instanz aufgerufen wird, die eine Änderung in der Blockchain bewirkt, muss eine Transaktion ausgelöst werden. Der Sender der Transaktion muss dabei für die Kosten für gas und allfällige weitere Kosten (\#VGL. Bezahlbare Funktionen) aufkommen. Der Sender kann nicht nur ein Account sein, sondern auch ein weiterer Smart Contract, an dessen Adresse genügend Ether liegt, um die Transaktionskosten zu begleichen.

\paragraph{Bezahlbare Funktionen}
Einige Funktionen von Smart Contracts benötigen Ether, den man dem Aufruf hinzugibt. Dabei ist zu beachten, dass die gas Kosten und explizit gesendeter Ether nicht dasselbe sind. Wenn beispielsweise eine Dienstleistung oder Sache über einen Smart Contract verkauft werden soll, muss eine Menge Ether als Zahlungsmittel überweisen werden. Die Menge Ether ist im Smart Contract festgelegt und kann durch Inspektion des Programmcodes eingesehen werden. Sollte der Kunde zu wenig Ether schicken, kann der Smart Contract definieren, dass die Transaktion nicht erfolgreich ist und der Kunde sein Geld zurückerhält. Dazu kann die Transaktion selbst als nichtig erklärt werden und es muss nicht auf das Withdrawal Muster zurückgegriffen werden.\cite{solidity.readthedocs.io}

\subsubsection{Solidity}
\label{subsubsec:Solidity}
Solidity ist eine Programmiersprache zur Erstellung von Smart Contracts auf der \acrfull{EVM}. Sie kann auch auf anderen Blockchain Platoformen verwendet werden.\cite{cryptocoinnews.com/smart-contract-bitcoin,github.com/hyperledger/burrow}

Solidity wird, in Anlehnung auf den Ausdruck object-oriented, als contract-oriented bezeichnet, da die erstellenden Konstrukte in der Sprache \emph{contract} und nicht \emph{object} genannt werden. Konzeptionell beziehen sich die beiden Ausdrücke auf dasselbe Konzept.

\paragraph{Vererbung}
\label{para:Vererbung}
Wie Objektorientierte Sprachen kennt auch Solidity das Konzept der Vererbung\footnote{Mehrfachvererbung wird unterstützt}. Einerseits bedeutet das, dass Funktionalität bei der Entwicklung wiederverwendet werden kann. Andererseits, dass zur Laufzeit eine Instanz eines Smart Contracts auf einen weniger spezifischen Typ abgebildet werden kann, um bspw. nur gemeinsame Funktionalität von unterschiedlichen abgeleiteten Smart Contract Typen anzusprechen.