\section{Implementation}
\label{sec:Implementation}
Nachfolgend werden getroffene Entscheidungen zum Entwurf und zur Implementation der Komponenten beschrieben. Angetroffene Probleme werden vorgestellt und und deren Lösung erklärt\footnote{Konkrete technische Hindernisse mit Verweise auf Anhang zu Open Source changes/contributions oder auch technische Limitation wie bspw. go-ethereum mobile hat keine whisper API}.

Allfällige Abweichungen zur Konzeption (vgl. \ref{sec:Konzeption}, bspw. teilweise oder fehlende Implementation, werden erwähnt und, wo angebracht, werden weitere Überlegungen und Möglichkeiten zur Erweiterung der Komponenten erläutert.

\subsection{Smart Contracts}
\label{subsec:Smart_Contracts}
Die Smart Contracts, die in Solidity implementiert wurden, werden nachfolgend erläutert. Diese Implementationen bilden das Rückgrat der Applikation. Sie bilden die Business Logik in Code Form ab und dienen als einzige Interaktionsmöglichkeit mir der Datenbank in der Blockchain.\cite[Introduction to Smart Contracts]{solidity.readthedocs.io}

\subsubsection{Generell}
Folgende Informationen treffen auf alle entworfenen Smart Conacts gleichermassen zu.
\paragraph{Datenhaltung}
In einem Smart Contract können Daten in der Blockchain auf unterschiedliche Arten gespeichert werden: \emph{Storage} oder \emph{Events} (auch \emph{Logs} genannt). Storage ist ein einfacher Schlüssel-Werte-Paar Speicher, worauf alle Instanzvariablen eines Smart Contracts gespeichert werden, die zwischen verschiedenen Funktionsaufrufen persistiert werden müssen (vgl. reservations Feld für Rentables). Ein Smart Contract kann nicht ausserhalb seines zugewiesenen Speicherbereichs operieren. Zugriffe auf diesen Speicher sind teuer. So soll verhindert werden, dass grosse Speichermengen in der Blockchain verwendet werden. Ausgelöste Events werden in der Blockchain in Form von Transactionlogs gespeichert. Diese Logs sind sehr günstig (vgl. gas price) anzulegen, können aber von einem Smart Contract nicht gelesen werden. Über die web3 API kann auf die so erstellten Logs zugegriffen werden.\cite[Miscellaneous, Introduction to Smart Contracts]{solidity.readthedocs.io}\cite{jonathanpatrick.me/ethereum}

\#TODO: insert Beispiel

Wenn eine Instanz eines Smart Contracts persistent Daten speichern und diese Daten in einem späteren Funktionsaufruf abfragen möchte, muss zwingend Storage Speicher verwendet werden. Damit die Konsistenz der Reservationen eines mietbaren Objektes gewährleistet werden kann, muss der Rentable Smart Contract die Möglichkeit besitzen, zukünftige Reservationen abzufragen. Daher ist es unumgänglich für den Rentable Smart Contract, Storage Speicher für die Datenhaltung der Reservationen zu verwenden. Um den benötigten Speicher, und die damit verbundenen Reservationskosten, gering zu halten könnten vergangene Reservationen auch gelöscht werden (vgl. \ref{subpara:Stalling}).

\subsubsection{Rentable}
\label{subsubsec:Rentable}
Vgl. \ref{sys_subsubsec:Rentable}

Damit alle mietbaren Objekte logisch unabhängig von einander sind, wurde der primäre Smart Contract so entworfen, dass für jedes mietbare Objekt eine separate Instanz dessen erstellt werden muss (vgl. \ref{subsubsec:Neuerstellung}). Die in der Blockchain liegende Funktionalität beinhaltet nur das Mieten, und die damit verbundene Monetären Transaktionen. Der Smart Contract weist dabei keine lokkit-spezifische Funktionalität auf. Bei dem Design wurde darauf geachtet, die Funktionalität zu abstrahieren, um es Autoren zu ermöglichen, weitere Dienste zu erstellen, die auf dem Konzept der mietbaren Objekte basiert. Diese darauf aufbauenden Dienste können auch ausserhalb des lokkit Systems bestehen und können gänzlich inkompatibel zu diesem sein.

\paragraph{Withdrawal Muster}
\label{para:Withdrawal_Muster}
Bei Transaktionen, die einen Account zum Ziel haben, werden die gas-Kosten von 500 gas automatisch vom Sender beigefügt, ohne dass dies explizit in der ausgelösten Transaktion angegeben werden muss. Ist das Ziel aber eine Funktion eines Smart Contracts (wie es bei Rentable.rent der Fall ist) oder ein Smart Contract selbst, so kann der Smart Contract, der die Transaktion erhält, Code ausführen, der vom initialen Sender der Transaktion bezahlt werden muss (vgl. gas). Um dies zu verhindern, sollte nicht Ether an eine Adresse überwiesen werden, von der nicht bekannt ist, ob sie ein Smart Contract oder ein Account ist.\cite[Wiki/Contracts and Transactions]{go-ethereum}\cite{cryptocompare.com/gas}\cite[FAQ/What is the deal with...]{solidity.readthedocs.io}

\subparagraph{Beispiel}
Sei A eine Instanz eines Rentable Contracts, der das Withdrawal Muster implementiert. Wenn ein Depot zurückerstattet wird, überweist A Ether nicht direkt an eine Zieladresse, B. Stattdessen merkt sich A die Menge Ether, die B zusteht und stellt die Möglichkeit zur Verfügung, dass B Ether vom Smart Contract abheben kann. Dies findet mittels einer Transaction auf \emph{withdraw} statt, die von B ausgelöst werden muss. Die gas-Kosten für die primär von B ausgeführte \emph{withdraw} Funktion sind vernachlässigbar und werden durch die zurückerhaltene Menge Ether kompensiert. Der Vorteil, wenn die Transaktion von B gestartet werden muss, ist, dass B für die etwaigen zusätzlichen gas-Kosten aufkommen muss, sollte B ebenfalls ein Smart Contract sein.

\#möglicherweise ein bildli zeichnen oder beispielcode einfügen

\paragraph{Re-Entrancy}
Hierbei handelt es sich um ein Muster, das angewendet wird, wenn in einem Smart Contract ein interner Zustand existiert, der die Menge an Ether speichert, der \emph{anderen} zusteht und eine Möglichkeit besteht, diese Menge Ether zu entnehmen (vgl. \ref{para:Withdrawal_Muster}). Beispiele für zurückzuerstattenden Ether kann bspw. Depots wie bei lokkit oder ein Gebot in einer Auktion sein.\cite[Security Considerations/Re-Entrancy]{solidity.readthedocs.io}

\subparagraph{Beispiel}
Sei A eine Instanz eines Rentable Contracts, der diesen erwähnten internen Zustand speichert und somit das Withdrawal Muster implementiert. Unter der Annahme, dass die Zieladresse für die Rückerstattung ein beliebiger Smart Contract B ist, kann B A angreifen. Wenn eine Transaktion ausgelöst wird, wird jeweils nicht nur der Betrag in Ether überwiesen, sondern, sollte das Ziel ein Smart Contract sein, auch Code ausgeführt. Das heisst, dass B auf eine eingehende Überweisungen reagieren kann und ihrerseits erneut die Transaktionsfunktion von A aktivieren kann (vgl. \ref{para:Withdrawal_Muster}), bevor die Kontrolle an den ursprünglichen Aufruf von A zurückgegeben wird. Wenn der Zustand von A noch nicht geändert wurde, wird der Betrag erneut gesendet, bis A keinen Ether mehr zur Verfügung hat.

\subparagraph{Implementationsbeispiel}
Um mehrfaches Überweisen von Ether zu verhindern, ist es unvermeidbar, zuerst den internen Status des Vertrags zu ändern, bevor Ether überwiesen wird. Die \emph{total} zur Verfügung stehende Menge Ether eines Smart Contracts wird in der Blockchain gehalten und ist Teil des Konsensus. Es ist somit nicht möglich, dass mehr Ether ausgegeben wird als in dem jeweiligen digitalen Vertrag vorhanden ist. 

Im Codebeispiel \ref{lst:withdraw_erroneous} kann die \emph{send} Anweisung in Zeile zwei mehrmals ausgeführt werden, da das deposit erst zurückgesetzt wird, sobald die Übertragung erfolgreich war. Dabei ist zu bemerken, dass die Funktion .send(...) die Kontrolle an die default-Funktion des Zielvertrags übergibt und deren Code ausgeführt wird.
\begin{lstlisting}[language=javascript,caption={fehlerhaftes Code Snippet \protected{\cite[Common Patterns/Withdrawal From Contrats]{solidity.readthedocs.io}}},label={lst:withdraw_erroneous}]
    function withdraw() {
        if (msg.sender.send(deposit[msg.sender])) {
            deposit[msg.sender] = 0;
        }
    }
\end{lstlisting}

Im Codebeispiel \ref{lst:withdraw_good} wehrt die dritte Zeile die Re-Entrancy Attacke ab, da der interne Kontostand zurückgesetzt wird, bevor die Transaktion ausgelöst wird. Auch hier wird der default-Funktion des Zielvertrags die Kontrolle übergeben. Im Fall, dass diese aber erneut die \emph{withdraw} Funktion aufruft, wird durch \emph{msg.sender.transfer(0)} keine erneute Transaktion auslöst.
\begin{lstlisting}[language=javascript,caption={empfohlenes Code Snippet \protected{\cite[Common Patterns/Withdrawal From Contrats]{solidity.readthedocs.io}}},label={lst:withdraw_good}]
    function withdraw() {
        var currentRefund = deposit[msg.sender];
        deposit[msg.sender] = 0;
        msg.sender.transfer(currentRefund);
    }
\end{lstlisting}

\paragraph{Weitergehende Überlegungen}
Mögliche Verbesserungen bzgl. der momentanen Implementation.

\subparagraph{Migrations}
Um neue oder geänderte Funktionalität in Smart Contracts zur Verfügung zu stellen, muss die Datenhaltung von der Businesslogik entkoppelt werden. Grund dafür ist, dass wenn ein neuer Smart Contract als Interaktionsmöglichkeit in der Bockchain steht, Daten, die durch Transaktionen in der Blockchain entstanden sind, nicht einfach übernommen werden können, wie beispielsweise Reservationen. Diese Daten könnten prinzipiell durch den Besitzer des Objekts migriert werden. Das würde aber bedeuten, dass in der Blockchain der Besitzer des Objekts im Namen seiner Mieter Reservationen tätigt, was seinerseits wiederum eine Sicherheitslücke und mögliches Missbrauchspotential seitens des Besitzers bedeutet.

Truffle Migrations?

\subparagraph{Stalling}
\label{subpara:Stalling}
Da die Laufzeit der rent Funktion von der Anzahl Reservationen abhängig ist, müssen die Gaskosten für den Aufruf entsprechend abhängig von der bestehenden Anzahl Reservationen gemacht werden. Wenn ein Rentable viele Reservationen erhält kann es sein, dass es durch das \acrfull{BGL}, das im Genesis block angegeben wird, verunmöglicht wird, neue Reservationen zu tätigen.\cite[Security Considerations/Gas Limit and Loops]{solidity.readthedocs.io}\cite{media.consensys.net/gas-and-fuel}

\#todo: formel für maximale Anzahl Reservationen

Wenn der owner das deposit zurückerstattet, könnte die abgelaufene Reservation aus dem internen Array gelöscht werden, um die storage Datenmenge des Smart Contracts gering zu halten. Die Historischen Daten zu dem mietbaren Objekt können von einem Benutzer noch immer eingesehen werden, da die Logs in der Blockchain noch vorhanden sind. Der Vorteil dadurch wäre, dass die 


\subsection{Real-Time Kommunikationsschnittstelle}
\label{subsec:Real_Time_Kommunikationsschnittstelle}
Für Implementationsdetails, vgl. \ref{sys_subsec:Real_Time_Kommunikationsschnittstelle}

Da die Block Time in der Ethereum Blockchain etwa 12 Sekunden beträgt, sind Transaktionen nicht nützlich, um in Echtzeit mit einem gemieteten Objekt zu interagieren. Auch die dabei anfallenden Kosten einer Transaktion\footnote{Diese Kosten sind gering für einfaches Signaling mit Smart Contracts.} sind zu begleichen und speziell bei wiederholtem Senden der Signale nicht zu verachten. Die Persistenz in der Blockchain all dieser Interaktionen dient keinem Nutzen, da aus dem Smart Contract bekannt ist, dass der Benutzer Zugriff auf das Gerät hat. \cite{blog.ethereum.org/block-time}

Daher wurde, um mit mietbaren Objekten (vgl. \ref{subsec:Smart_Contracts}) während des gemieteten Zeitraums in Echtzeit zu interagieren, das Protokoll Whisper v5 (vgl. \ref{para:Whisper}) verwendet. Whisper v5 erlaubt die Übermittlung von textbasierten Nachrichten mit eingebautem Sicherheitsmechanismus zur Verschlüsselung und optionale Signatur von Nachrichten. Diese Nachrichten müssen entweder symmetrisch oder asymmetrisch verschlüsselt werden.\cite[Wiki/Whisper Usage]{go-ethereum}

Da Whisper v5 die einzige Möglichkeit zur Echtzeitkommunikation in der Ethereum Blockchain ist, gibt es keine Alternativen dazu.

\subsubsection{Verteilung}
\label{subsubsec:Verteilung}
Das Whisper v5 Protokoll setzt für jede Nachricht einen Schlüssel (symmetrisch oder asymmetrisch) und ein Topic (4 bytes) voraus. Whisper Abos müssen mindestens ebenfalls einen Schlüssel und ein Topic als Filter beinhalten. Um neuen Teilnehmern zu er möglichen, auf diese Nachrichten zu hören und solche zu senden, wird ein symmetrischer Schlüssel mit dem Passwort \emph{lokkit} erstellt. Dieser Schlüssel muss nicht geheim gehalten werden, da der Inhalt der Nachricht nicht sicherheitsrelevant ist\footnote{Sollte in Zukunft die Anforderung an verschlüsselte Commands gestellt werden, vgl Anhang \#TODO: generate asymmetric key + in smart contract schreiben. --> vgl. Sicherheitsaspekte. Müsste transaction auslösen von doorman}. Als Topic werden die ersten 4 Bytes der sha3 Checksumme der Adresse des Mietbaren Objektes mitgeschickt. Basierend auf diesen beiden Eigenschaften kann der Doorman (vgl. \ref{subsec:Doorman}) die für die angeschlossenen Geräte relevanten Nachrichten filtern.\cite[Wiki/Whisper Overview]{go-ethereum}

\subsubsection{Sicherheitsaspekte}
\label{subsubsec:Sicherheitsaspekte}
Auch wenn Whisper v5 garantiert, dass die übermittelten Nachrichten nach gängigen Sicherheitsstandards verschlüsselt werden, können Design-Lücken bei der Implementation der Real-Time Kommunikationsschnittstelle es einem Angreifer ermöglichen, das System auf eine nicht erwünschenswerte Art zu missbrauchen.\cite[Wiki/Whisper Overview/Encryption in version 5]{go-ethereum}

\emph{In den folgenden Paragraphen wird Vorwissen um die Real-Time Kommunikationsschnittstelle vorausgesetzt. Vgl. \ref{sys_subsec:Real_Time_Kommunikationsschnittstelle} für technische Details der Schnittstelle und deren Implementation.}

\paragraph{Signatur des Message Objektes}
Der Sender/Empfänger Mechanismus von Whisper ist nicht an die Accounts/Adressen der Blockchain gekoppelt. Da mietbare Objekte (in Form von Smart Contracts) von einer Adresse gemietet werden, wird ein Sicherheitsmechanismus benötigt, um sicher zu stellen, dass der Envelope von einer Entität geschickt wurde, die im Besitz des in der Blockchain angegebenen Accounts ist. Dafür wurde die Funktion \emph{web3.eth.sign(...)} verwendet, um das Message Objekt zu signieren. Damit diese Funktion einen Wert zurück liefert, muss der Private Key des angegebenen Accounts auf der lokalen Node vorhanden sein und dieser Account muss entsperrt sein. Sind diese Vorbedingungen erfüllt, liefert \emph{web3.eth.sign(...)} für einen gegebenen Input (in diesem fall das Message Objekt) einen 65 Byte Hash, Digest genannt, zurück. Wenn bspw. ein Empfänger der Nachricht Funktion \emph{web3.eth.personal.ecRecover(...)} dasselbe Message Objekt und den erhaltenen Digest als Parameter übergibt, gibt diese Funktion die öffentliche Adresse zurück, die den Digest erstellt hat. Diese öffentliche Adresse kann dann mit der eingetragenen Adresse im Smart Contract abgeglichen werden.\cite[web3.eth/sign, web3.eth.personal/ecRecover]{web3js.readthedocs.io}

\paragraph{Replay Attack}
\label{para:Replay_Attack}
Folgend wird der einzige bekannte technische Angriff auf die Real-Time Schnittstelle beschrieben und erläutert wie dieser, unter Verwendung der in Ethereum eingebauten kryptographischen Funktionen, verhindert werden kann. Jegliche Angriffsvektoren, die die Referenzimplementation \emph{geth}, die \acrshort{EVM} oder natürliche Personen (d.h. Social Engineering) betreffen, werden nicht beschrieben oder entschärft.\cite[web3.eth/sign, web3.eth.personal/ecRecover]{web3js.readthedocs.io}\cite{keccak.noekeon.org}

Jeder Whisper Envelope muss mit einem symmetrischen oder asymmetrischen Schlüssel verschlüsselt werden und benötigt ein Topic (vgl. \ref{subsubsec:Verteilung}).
Auch für jedes Abonnement von Whispers muss ein symmetrischer oder asymmetrischer Schlüssel und mindestens ein Topic als Filter angegeben werden. Da der Symmetrische Schlüssel für lokkit Envelopes öffentlich ist, ist er nicht für kryptographische Sicherheit, sondern nur für die Filterung der Envelopes, zu verwenden. Aus diesem Grund ist es für jeden Teilnehmer, der den Envelope auf seiner Node übermittelt, möglich, diesen aufzuzeichnen, die Payload zu extrahieren und erneut zu schicken.\cite{replay_attack_on_security_protocols}

Diese Art der Weiterleitung funktioniert, wenn die gesamte Payload inklusive Digest weitergeleitet würde und somit keine erneute Signatur des Message Objektes nötig wäre. Somit wäre es möglich, eine Payload zu erhalten, die nicht von der signierenden Entität sondern von einer Drittperson gesendet wurde. Um sicher zu gehen, dass die Nachricht von derselben Entität gesendet wurde, die auch den Digest des Message Objektes erstellt hatte, wird das \emph{key} Attribut (vgl. \ref{sys_para:Key}) ebenfalls in das Message Objekt eingebettet. Dies ist derselbe Schlüssel, der zur Signatur des Whisper Envelopes verwendet wurde. Diese beiden Schlüssel können verglichen werden (vgl. \ref{sys_subsubsec:Verteilung}, um sicher zu gehen, dass der Sender der Whisper Nachricht auch derselbe ist, wie der, der den Digest erstellt hat.

\#todo: bild. dringend. den obigen Abschnitt checke ich selbst nicht, 30 Minuten nachdem ich ihn gelesen hab'...

\subsection{Webapp}
\label{subsec:Webapp}
Die Webapp ist die Hauptinteraktionsmöglichkeit von Benutzern mit dem Lokkit System...

\subsection{Mobile Geräte}
Um die Webapp zu benutzen, wird eine lokale Ethereum Node vorausgesetzt, die mit einer bestimmten Konfigurationen läuft (vgl. \ref{subsec:Webapp}, \ref{sys_subsec:Geth}). Da diese beiden Komponenten über die web3 Schnittstelle komunizieren ist es auch möglich auf mobilen Geräten die Webapp zu benutzen, sofern eine beschriebene Ethereum Node auf diesem Gerät verbunden ist.

\subsubsection{geth auf Mobilgeräten}
Das Ethereum Projekt bietet eine offizielle API an, um auf mobilen Geräten eine Ethereum Node im light mode zu betrieben. Dabei ist zu bemerken, dass die API nur native Apps unterstützt und keine der Funktionalitäten über die rpc Schnittstelle veröffentlicht werden kann. Somit ist es nicht möglich mit der offiziellen API \acrshort{DAPPs} zu erstellen und auf einem Mobilgerät darauf zuzugreifen.\cite[wiki/Mobile: Introduction]{go-ethereum}

Die Status-im Plattform bietet genau diese Interaktionsmöglichkeit. Diese Applikation wurde entworfen, um auf mobilen Platformen die Verwendung von \acrshort{DAPPs} zu ermöglichen. Dabei wurde ein Modul basierend auf der go-ethereum Library von ethereum erstellt (vgl. github.com FORK), das die benötigten Schnittstellen von geth über rpc frei gibt und Verbindungen von localhost zulässt. Somit können \acrshort{DAPPs} auf mobilen Geräten verwendet werden. \cite{status-im_whitepaper, github.com/status-im/status-go}


Die Interaktionsmöglichkeiten zum Lokkit System auf mobilen Geräten beschränkt sich momentan auf Androidgeräte mit Android version 4.4 oder höher.

\subsection{Android App}

\subsubsection{}


\subsection{Doorman}
\label{subsec:Doorman}
Doorman ist eine mögliche Implementation in Python 2.7, die es ermöglicht, ein IoT Gerät an die erwähnten Smart Contracts (vgl. \ref{subsec:Smart_Contracts}) und das Protokoll Whisper v5 (vgl. \ref{para:Whisper}) inkl. der definierten Schnittstelle (vgl. \ref{subsec:Real_Time_Kommunikationsschnittstelle}) anzubinden. Doorman verbindet sich mit einer angegebenen Ethereum Node, lädt die Informationen zum angegebenen Smart Contract und wartet auf Mitteilungen (vgl. \ref{subsec:Konfiguration}). Wenn eine Nachricht erhalten und der Absender erfolgreich verifiziert wurde, wird der angegebene Befehl in der Shell ausgeführt.

\subsubsection{Wieso Python? Wieso Python 2.7?}

\subsection{Controllers}
Controllers für IoT device
\subsubsection{Nuki}

\subsubsection{Marke: Eigenbau}
